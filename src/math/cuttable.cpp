#include "edittable.h"

// Функция выделяет из таблицы (table) заданную подтаблицу соответствующую определённому
// интервалу значений по Х, заданнаму начальным значением (start) и конечным
// значением (finish).

VectorTable edt::cuttable( const VectorTable& table, double start, double finish )
{
// В начале проверяем заданный интервал на корректность. Если начальное значение больше
// или равно конечному...
    if ( start >= finish )
// ...то программа немедленно завершается.
        qFatal( "cuttable: start >= finish" );

// Получаем доступ на чтение памяти в которой хранится первый столбец таблицы (в
// котором храняться значения по X). Доступ осуществляется посредством
// константного указателя на QVector<double>. Указатель получается посредством
// вызова соответствующей функции класса VectorTable.
    const QVector<double>* scale = table.getColumn( table.getTags().first() );

// Инициализируем значением -1 переменные pos в которой будет храниться номер
// строки таблицы с которого начнётся искомая подтаблица и length в которой
// будет храниться длинна искомой подтаблицы.
    int pos = -1, length = -1;

// Пусть i указывает на первую ячейку столбца хранящего значения по X, j - на
// последнюю ячейку того же столбца, k равен начальному значению i. Тогда
// перебираем все ячейки этого столбца пока i не равен j.
    for ( QVector<double>::const_iterator i = scale->begin(), j = scale->end(),
                                                            k = i; i != j; i++ )
    {
// Для каждой ячейки...
//
// Если номер первой строки искомой подтаблицы не менялся с начала поиска (то
// есть всё ещё равен -1) и значение рассматриваемой ячейки больше значения
// начала интервала...
        if (( pos == -1 ) && ( *i > start ))
// ..то номер первой строки искомой подтаблицы становится равен числу переходов
// от начальной к текущей ячейке (использована особая магия итераторов, про неё
// читать в умных книгах).
            pos = i - k;

// Если номер первой строки искомой подтаблицы изменился с начала поиска (то
// есть не равен -1) и значение рассматриваемой ячейки больше значения конца
// интервала...
        if (( pos != -1 ) && ( *i > finish ))
        {
// ..то длинна искомой таблицы становится равна положению текущей ячейки, минус
// положение начальной ячейки, минус номер первой строки искомой подтаблицы
// минус один (как это объяснять, я вообще не знаю, нарисуй),
            length = i - k - pos - 1;
// а поиск немедленно прекращается.
            break;
        }
    }

// Возвращаем сечение входной таблицы начиная со строки pos и длинной length.
// Сечение осуществляется при помощи функции встроенной в контейнер.
    return table.mid( pos, length );
}
